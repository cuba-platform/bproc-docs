[[process-forms]]
== Process Forms

Process forms are screens displayed to users. They may be configured for `StartEvent` and `UserTask` model elements. There are two process form types: _CUBA screen_ and _Input dialog_.

[[input-dialog-process-form]]
=== Input Dialog Process Form

Parameters of input dialogs are defined right in the process model. If you click on `StartEvent` or `UserTask` model element, then on the properties panel you will be able to configure a related process variable, datatype, parameters ordering, etc. When users start processes or complete tasks, input dialogs are automatically rendered based on the configuration you provided in the model.

The input dialog parameter editor looks as follows:

image::process-forms/form-field-editor.png[]

Supported parameter types are:

* string
* multi line string
* number
* boolean
* date
* date with time
* user
* user list
* entity
* entity list
* file
* platform enum
* custom enum

Depending on the selected type, additional components may be displayed. For example, for _entity_ and _entity list_ types you should select an entity class from the dropdown list, a UI component (LookupField or PickerField) and optionally a lookup screen or JPQL query (default values will be used if these fields are left blank).

A _user_ and _users list_ types work like _entity_ and _entity list_ types with the `sec$User` meta class. An additional piece of functionality in the modeler related to these field types is that you will be able to select these parameters as assignee value of `UserTask` elements.

image::process-forms/user-task-form-field-assignee.png[]

[[cuba-screen-process-form]]
=== CUBA Screen Process Form

In many cases you'll probably need a process form with a complex layout and behavior. In this case, instead of <<input-dialog-process-form, input dialog forms>> (which are defined right in a process model) you may an existing CUBA screen. To be used as a process form, the screen controller should be annotated with the `@ProcessForm` annotation and should implement the `ProcessFormContextAware` interface.

The `@ProcessForm` annotation indicates that the screen must appear in the process forms lookup in the modeler.

The `ProcessFormContextAware` interface has the single `void setProcessFormContext(ProcessFormContext processFormContext)` method. When the process form is opened the `ProcessFormContext` object is set. The `ProcessFormContext` contains information about a process to be started (when the form is used for starting the process) or a user task to be completed and methods for working with them (start process, complete task, etc). Without the `ProcessFormContext` the process form is barely useful.

[[process-variables-in-cuba-screen-form]]
==== Process Variables in CUBA Screen Form

A `@ProcessVariable` annotation may be placed on injected UI components or on regular class fields. It indicates that the value of the UI component or class field will be written to a process variable when the process is started or the task is completed using the form. If the form is used for user task completion then the annotated field will have a value of the corresponding process variable when the form screen is displayed.

[source, java]
----
@ProcessVariable
private Date orderDate;

@Inject
@ProcessVariable(name = "approver")
private LookupField<User> approverLookup;
----

A `@ProcessVariable` annotation may have an optional `name` attribute. The value of this attribute is the process variable name. If the `name` attribute is missing, then a field name is used as a process variable name.

[[using-the-process-form-context]]
==== Using the ProcessFormContext

You will use different methods of the `ProcessFormContext` when working with start process forms and task process forms.

For start process form the useful methods are:

* `void startProcess()` - method starts the process. A process variables map is built using the fields annotated with the `@ProcessVariable`.
* `void startProcess(String businessKey)` - this method set a business key when starting the process. The process variables are collected from the annotated class fields.
* `void startProcess(String businessKey, Map<String, Object> processVariables)` - use this method if you want to collect a map with process variables manually ignoring fields annotated with the `@ProcessVariable`.
* `ProcessDefinitionData getProcessDefinitionData()` - returns a `ProcessDefinitionData` object.

For task process form:

* `completeTask()` - completes the task without any outcome and using the process variables collected from `@ProcessVariable` annotated fields.
* `completeTask(Map<String, Object> processVariables)` - completes the task without any outcome and using the explicitly passed process variables map.
* `completeTaskWithOutcome(String outcome)` - completes the task with an outcome and using the process variables collected from annotated fields.
* `completeTaskWithOutcome(String outcome, Map<String, Object> processVariables)` - completes the task with an outcome and using the explicitly passed process variables map.
* `TaskData getTaskData()` - returns a `TaskData` object that contains information about the user task.

[[declare-task-outcomes-for-the-modeler]]
==== Declare Task Outcomes for the Modeler

In the modeler, for the sequence flow element, we may define a condition by selecting a user task and its outcome from the dropdown list. To fill this list for a user task that uses a _CUBA screen_ process form you may declare a list of possible outcomes in the form controller. Use the `outcomes` attribute of the `@ProcessForm` annotation for that:

.TaskApprovalForm.java
[source, java]
----
@ProcessForm(outcomes = {
        @Outcome(id = "approve"),
        @Outcome(id = "reject")
})
@UiController("ref_TaskApprovalForm")
@UiDescriptor("task-approval-form.xml")
public class TaskApprovalForm extends Screen implements ProcessFormContextAware {
    //...
}    
----

[[cuba-screen-process-form-parameters]]
==== CUBA Screen Process Form Parameters

_CUBA screen_ process forms may accept external parameters defined in the modeler. For example, you need a form for next process actor selection. The form must display a lookup field with users and save the result into some process variable. We want to use the form for selecting different actors at different process steps, so the form should have two parameters:

* variableName
* lookupCaption

The form parameters used by the form are defined in the `params` attribute of the `@ProcessForm` annotation:

[source, java]
----
@ProcessForm(params = {
        @Param(name = "variableName"),
        @Param(name = "lookupCaption")
})
----

These parameters are read by the modeler and are displayed in the modeler when you select the screen.

image::process-forms/custom-form-params.png[]

You can edit the parameters and give them values:

image::process-forms/custom-form-param-edit.png[]

You can provide a direct param value (value source is _Direct value_) or use one of the existing process variables as a parameter value (value source is _Process variable_).

Inside the process form controller use the `@ProcessFormParam` annotation on class fields to get parameter values:

[source, java]
----
@ProcessFormParam(name = "variableName")
private String variableNameParam;

@ProcessFormParam
private String lookupCaption;
----

Like the `@ProcessVariable` annotation, the `@ProcessFormParam` supports an optional `name` attribute. If the attribute is not defined, then a field name is used as a parameter name.

Another way to get a full list of process form parameters is to get them from the `ProcessFormContext` object:

[source, java]
----
List<FormParam> formParams = processFormContext.getFormData().getFormParams();
----

The source code of the actor selection form:

.actor-selection-form.xml
[source, xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<window xmlns="http://schemas.haulmont.com/cuba/screen/window.xsd"
        caption="msg://caption"
        messagesPack="com.haulmont.bproc.ref.web.screens.forms.actorselection">
    <data>
        <collection id="usersDc" class="com.haulmont.cuba.security.entity.User" view="_minimal">
            <loader id="usersDl">
                <query><![CDATA[select u from sec$User u order by u.name]]></query>
            </loader>
        </collection>
    </data>
    <layout spacing="true">
        <form width="400px">
            <lookupField id="userLookup" optionsContainer="usersDc" width="100%"/>
        </form>
        <hbox spacing="true">
            <button id="completeTaskBtn" icon="font-icon:CHECK" caption="msg://completeTask"/>
        </hbox>
    </layout>
</window>
----

.ActorSelectionForm.java
[source, java]
----
@ProcessForm(params = {
        @Param(name = "variableName"),
        @Param(name = "lookupCaption")
})
@UiController("ref_ActorSelectionForm")
@UiDescriptor("actor-selection-form.xml")
@LoadDataBeforeShow
public class ActorSelectionForm extends Screen implements ProcessFormContextAware {

    @Inject
    private LookupField<User> userLookup;

    @ProcessFormParam(name = "variableName")
    private String variableNameParam;

    @ProcessFormParam
    private String lookupCaption;

    private ProcessFormContext processFormContext;

    @Override
    public void setProcessFormContext(ProcessFormContext processFormContext) {
        this.processFormContext = processFormContext;
    }

    @Subscribe
    private void onBeforeShow(BeforeShowEvent event) {
        userLookup.setCaption(lookupCaption);
    }

    @Subscribe("completeTaskBtn")
    private void onCompleteTaskBtnClick(Button.ClickEvent event) {
        Map<String, Object> processVariables = new HashMap<>();
        processVariables.put(variableNameParam, userLookup.getValue());
        processFormContext.completeTask(processVariables);
        closeWithDefaultAction();
    }
}
----

[[restrict-process-form-usage]]
==== Restrict Process Form Usage

By default, all process forms screens are available within any process model. If some screen is intended to be used in particular processes only, then you should specify processes keys in the `allowedProcessKeys` attribute of the `@ProcessForm` annotation.

[source, java]
----
@ProcessForm(allowedProcessKeys = {"process-1", "process-2"})
----

The form will be available only for process with `process-1` and `process-2` keys (_Process id_ in the modeler).

[[process-process-forms-examples]]
==== Process Forms Examples

[[task-process-form-example]]
===== Task Process Form Example

.task-approval-form.xml
[source, xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<window xmlns="http://schemas.haulmont.com/cuba/screen/window.xsd"
        caption="msg://caption"
        messagesPack="com.haulmont.bproc.ref.web.screens.taskapproval">
    <layout expand="actionsPanel" spacing="true">
        <form>
            <textField id="orderNumber" caption="msg://orderNumber"/>
            <dateField id="orderDate" caption="msg://orderDate"/>
        </form>
        <hbox id="actionsPanel" spacing="true">
            <button id="approveBtn" caption="msg://approve" icon="font-icon:CHECK"/>
            <button id="rejectBtn" caption="msg://reject"  icon="font-icon:BAN"/>
        </hbox>
    </layout>
</window>
----

.TaskApprovalForm.java
[source, java]
----
@ProcessForm(outcomes = { <1>
        @Outcome(id = "approve"),
        @Outcome(id = "reject")
})
@UiController("ref_TaskApprovalForm")
@UiDescriptor("task-approval-form.xml")
public class TaskApprovalForm extends Screen implements ProcessFormContextAware {

    @ProcessVariable <2>
    @Inject
    private TextField<String> orderNumber;

    @ProcessVariable
    @Inject
    private DateField<Date> orderDate;

    private ProcessFormContext processFormContext;

    @Override
    public void setProcessFormContext(ProcessFormContext processFormContext) {
        this.processFormContext = processFormContext;
    }

    @Subscribe("approveBtn")
    protected void onApproveBtnClick(Button.ClickEvent event) {
        processFormContext.completeTaskWithOutcome("approve"); <3>
        closeWithDefaultAction();
    }

    @Subscribe("rejectBtn")
    protected void onRejectBtnClick(Button.ClickEvent event) {
        processFormContext.completeTaskWithOutcome("reject");
        closeWithDefaultAction();
    }
}
----
<1> The form defines two possible outcomes that may be used in sequence flow node condition in the modeler.
<2> The value of the _orderNumber_ process variables will be set to the _orderNumber_ text field when the form is displayed. The same is for _orderDate_ process variable.
<3> Button click event handler completes the task with a given outcome. If values of _orderNumber_ or _orderDate_ fields were changed, the new values will be written to process variables.

[[entity-edit-process-form-example]]
===== Entity Edit Process Form Example

The next form demonstrates the following case. There is an `Order` entity in the project. In the entity editor screen, there is a button that starts the order approval process programmatically. The start process button click handler may be as follows:

[source, java]
----
@Subscribe("startProcessBtn")
protected void onStartProcessBtnClick(Button.ClickEvent event) {
    Order order = getEditedEntity();
    Map<String, Object> processVariables = new HashMap<>();
    processVariables.put("orderId", order.getId()); <1>
    processVariables.put("approver", order.getManager()); <2>
    bprocRuntimeService.startProcessInstanceByKey("order-approval",
            order.getNumber(),
            processVariables);
}
----
<1> The _orderId_ process variable will be used later in form to find the corresponding `Order` entity instance.
<2> The _approver_ process variable is used in the process for use task assignment.

In the task process form we want to display and edit fields of the `Order` entity. The form layout descriptor looks pretty similar to a regular entity editor screen:

.order-edit-task-form.xml
[source, xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<window xmlns="http://schemas.haulmont.com/cuba/screen/window.xsd"
        caption="msg://caption"
        messagesPack="com.haulmont.bproc.ref.web.screens.forms.documentation.orderedit">
    <data>
        <instance id="orderDc"
            class="com.haulmont.bproc.ref.entity.Order"
            view="order-edit"/>
        <collection id="clientsDc" class="com.haulmont.bproc.ref.entity.Client">
            <loader>
                <query><![CDATA[select c from ref_Client c]]></query>
            </loader>
        </collection>
    </data>
    <layout spacing="true">
        <form dataContainer="orderDc">
            <column>
                <textField property="number"/>
                <dateField property="date"/>
                <lookupField property="client" optionsContainer="clientsDc"/>
            </column>
        </form>
        <hbox spacing="true">
            <button id="completeTaskBtn"
                caption="msg://completeTask"
                icon="font-icon:CHECK"/>
        </hbox>
    </layout>
</window>
----

The Java controller:

.OrderEditTaskForm.java
[source, java]
----
@ProcessForm
@UiController("ref_OrderEditTaskForm")
@UiDescriptor("order-edit-task-form.xml")
@LoadDataBeforeShow
public class OrderEditTaskForm extends Screen implements ProcessFormContextAware {

    @Inject
    private DataManager dataManager;

    private ProcessFormContext processFormContext;

    @Inject
    private InstanceContainer<Order> orderDc;

    @ProcessVariable
    private UUID orderId; <1>

    @Override
    public void setProcessFormContext(ProcessFormContext processFormContext) {
        this.processFormContext = processFormContext;
    }

    @Subscribe
    private void onBeforeShow(BeforeShowEvent event) {
        Order order = dataManager.load(Order.class) <2>
                .id(orderId)
                .view("order-edit")
                .one();
        order = getScreenData().getDataContext().merge(order); <3>
        orderDc.setItem(order);
    }

    @Subscribe("completeTaskBtn")
    protected void onCompleteTaskBtnClick(Button.ClickEvent event) {
        getScreenData().getDataContext().commit(); <4>
        processFormContext.completeTask();
        closeWithDefaultAction();
    }
}
----
<1> The value of the _orderId_ variable will be injected to the field
<2> Load the `Order` entity with a given id and a proper view
<3> To track the changes of the _order_ entity we must merge it to the DataContext  (see link:{cuba_doc_url}/gui_DataContext.html[Data Context] section of CUBA Manual)
<4> When the _Complete Task_ button is clicked, the changes of the _Order_ entity is saved to the database and then the process task is completed